享元模式
享元（Flyweight）模式定义

Flyweight在拳击比赛中指最轻量级，即“蝇量级”或“雨量级”，这里选择使用“享元模式”的意译，是因为这样更能反映模式的用意。享元模式是对象的结构模式。享元模式以共享的方式高效地支持大量的细粒度对象。
Java中的String类型

在Java语言中，String类型就是使用了享元模式。String对象是final类型，对象一旦创建就不可改变。在Java中字符串常量都是存在常量池中的，Java会确保一个字符串常量池只有一个拷贝。String a = “abc”，其中"abc"就是一个字符串常量。

享元模式的结构

享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。***享元对象能做到共享的关键是区分内蕴状态（Internal State）和外蕴状态（External State）***。

一个内蕴状态是存储在享元对象内部的，并且是不会随环境的变化而有所不同。因此，一个享元可以具有内蕴状态并可以共享。

一个外蕴状态是随环境的改变而改变的、不可以共享的。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要的时候再传入到享元对象的内部。外蕴状态不可以影响享元对象的内蕴状态，它们是互相独立的。

享元模式可以分成单纯享元模式和复合享元模式两种形式。

单纯享元模式所涉及到的角色如下：

    抽象享元（Flyweight）角色：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。
    具体享元（ConcreteFlyweight）角色：实现抽象享元所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。
    享元工厂（FlyweightFactory）角色：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色就应当创建一个合适的享元对象。

享元对象的优缺点

享元模式的优点在于它大幅度地降低内存中对象的数量。但是，它做到这一点付出的代价也是很高的

    享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。
    享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。

PS：享元模式会使系统变得更加复杂，所以实际应用也不是很多。

享元模式在一般的项目开发中并不常用，而是常常用于系统底层的开发，以便解决系统的性能问题。

比如：Java中的String类型就是使用了享元模式。

到底系统需要满足什么样的条件才能使用享元模式。对于这个问题，总结出以下几点：

    一个系统中存在大量的细粒度对象
    这些细粒度对象消耗了大量的内存
    这些细粒度对象的状态中大部分都可以外部化
    这些细粒度对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组可以仅用一个对象代替。
    软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。

满足以上这些条件的系统可以使用享元模式。最后，使用享元模式需要维护一个记录了系统所有享元的哈希表，也称之为对象池，而这也需要耗费一定的资源。因此，应当在有足够多的享元实例可供分享时，才值得使用享元模式。