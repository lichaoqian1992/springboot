使用场景

假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘以数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。

根据描述，折扣是根据以下几个算法中的一个进行的：

算法一：对初级会员没有折扣。
算法二：对中级会员提供10%的促销折扣。
算法三：对高级会员提供20%的促销折扣。

使用策略模式来实现的结构图如下：

从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况使用什么算法是由客户端决定的。
认识策略模式
策略模式的重心

策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。
算法的平等性

策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以互相替换。所有的策略算法在实现上也是互相独立的，互相之间是没有依赖的。

所以，可以这样描述这一系列策略算法：策略算法是相同行为的不同表现。
运行时策略的唯一性

运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现切换，但是同时只能使用一个。
公有的行为

经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。

这其实也是典型的将代码向继承等级结构的上方集中的标准做法。

将代码向继承等级结构的上方集中
策略模式的优点

（1）策略模式提供了管理相关的算法族的方法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。

（2）使用策略模式可以避免使用多重条件（if-else）语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的方法还要原始和落后。
策略模式的缺点

（1）客户端必须知道素有的策略类，并自行决定使用哪个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法雷。换言之，策略模式只适用于客户端知道算法或行为的情况。

（2）由于策略模式把每个具体的策略实现都单独封装成类，如果备选的策略很多的话，那么对象的数目就会很可观。