模板方法模式
模板方法（Template Method）的定义

模板方法是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方法实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。
模板方法模式的结构

模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。

模板方法模式是需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称作基本方法（primitive method）；而将这些基本方法汇总起来的方法叫做模板方法（template method），这个设计模式的名字就是由此而来。

模板方法所代表的的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示

模板方法UML类图

这里涉及到了两个角色：
抽象模板角色（Abstract Template）角色有如下责任：

    定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。
    定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。

具体模板（Concrete Template）角色有如下责任：

    实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。
    每一个抽象模板角色都可以有多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。

源代码

抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。

public abstract class AbstractTemplate {

    /**
     * 模板方法
     */
    public void templateMethod() {
        // 调用基本方法
        abstractMethod();
        hookMethod();
        concreteMethod();
    }

    /**
     * 基本方法的声明（由子类实现）
     */
    protected abstract void abstractMethod();

    /**
     * 基本方法（空方法）
     */
    protected void hookMethod() {

    }

    /**
     * 基本方法（已经实现）
     */
    private final void concreteMethod() {
        // 业务相关代码
    }

}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32

具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而hookMethod()方法是可选择实现的逻辑，不是必须实现的。

public class ConcreteTemplate extends AbstractTemplate {
    // 基本方法的实现
    @Override
    protected void abstractMethod() {
        // 业务相关的代码
    }

    // 重写父类的方法
    @Override
    public void hookMethod() {
        // 业务相关的代码
    }
}

    1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13

模板模式的关键是：子类可以置换掉父类的可变部分，但是子类不可以改变模板方法所代表的顶级逻辑。

每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照责任的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板方法可以使这些责任变得清晰。
模板方法模板中的方法

模板方法中的方法可以分为两大类：模板方法和基本方法。
模板方法

一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。

一个抽象类可以有多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。
基本方法

基本方法又可以分为三种：抽象方法（Abstract Method）、具体方法（Concrete Method）和 钩子（Hook Method）。

    抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。
    具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。
    钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。

在上面的例子中，AbstractTemplate是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明并实现。
默认钩子方法

一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook"。显然，这种默认的钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认实现，从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。
命名规则

命名规则是设计师之间赖以沟通的管道之一，使用恰当的命名规则可以帮助不同的设计师之间沟通。

钩子方法的名字应以do开始，这是熟悉设计模式的Java开发人员的标准做法。在上面的例子中，钩子方法hookMethod()应当以do开头；在HttpServlet类中，也遵从这一命名规则，如doGet()、doPost()等方法。
使用场景

考虑一个计算贷款利息的例子。假设系统需要支持两种存款账号，即货币市场（Money Market）账号和定期存款（Certificate of Deposite）账号。这两种账号的存款利息是不同的，因此，在计算一个存户的存款利息额时，必须区分两种不同账号类型。

这个系统的总行为应当是计算出利息，这也就决定了作为一个模板方法模式的顶级逻辑应当是利息计算。由于利息计算涉及到两个步骤：一个基本方法给出账号种类，另一个基本方法给出利息百分比。这两个基本方法构成具体逻辑，因为账号的类型不同，所以具体逻辑会有所不同。

显然，系统需要一个抽象角色给出顶级行为的实现，而将两个座位细节步骤的基本方法留给具体子类实现。由于需要考虑的账号有两种：一是货币市场账号，二是定期存款账号。系统的类结构如下图所示。

模板方法模式在Servlet中的应用

使用过Servlet的人都清楚，除了要在web.xml做相应的配置外，还需要继承一个叫HttpServlet的抽象类。HttpServlet提供了一个service()方法，这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应。这些do方法需要由HttpServlet的具体子类提供，因此这是典型的模板方法模式。下面是service()方法的源代码。
