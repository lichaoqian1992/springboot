访问者模式
访问者模式（Visitor）的定义

访问者是对象的行为模式。访问者模式的目的是封装一些施加于某些数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。
分派的概念

变量被声明时的类型叫做变量的静态类型（Static Type），有些人又把静态类型叫做明显类型（Apparent Type）；而变量所引用的对象的真实类型又叫做变量的实际类型（Actual Type）。比如：

List list = null;
list = new ArrayList();

    1
    2

声明了一个变量list，它的静态类型（也叫明显类型）是List，而它的实际类型是ArrayList。

根据对象的类型而对方法进行的选择，就是分配（dispatch），分配（dispatch）又分为两种，即静态分配和动态分配。

静态分派（Static Dispatch）发生在编译时期，分派根据静态类型信息发生。静态分派对我们来说并不陌生，方法重载就是静态分配。

动态分派（Dynamic Dispatch）发生在运行时期，动态分派动态地置换掉某个方法。
静态分派

Java通过方法重载支持静态分派。用墨子骑马的故事作为例子，墨子可以骑白马或者黑马。墨子与白马、黑马和马的类图如下所示

显然，Mozi类的ride()方法是由三个方法重载而成的。这三个方法分别接受马（Horse）、白马（WhiteHorse）、黑马（BlackHorse）等类型的参数。

那么在运行时，程序会打印出什么结果呢？结果是程序会同时打印出“骑马”。换言之，墨子发现他骑的都是马。

为什么呢，两次对ride()方法的调用传入的是不同的参数，也就是wh和bh，它们虽然具有不同的真实类型，但是它们的静态类型都是一样的，均是Horse类型。

重载方法的分派是根据静态类型进行的，这个分派过程在编译过程就完成了。

动态分派

Java通过方法的重写支持动态分派。用马吃草的故事作为例子，代码如下所示：

变量h的静态类型就是Horse，而真实类型是BlackHorse。如果上面最后一行的eat()方法调用的是BlackHorse类的eat()方法，那么上面打印的就是“黑马吃草”；相反，如果上面的eat()方法调用的是Horse类的eat()方法，那么打印的就是“马吃草”。

所以，问题的核心就是Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。这样一来，上面最后一行的eat()方法调用的是BlackHorse()类的eat()方法，打印的是“黑马吃草”。
分派的类型

一个方法所述的对象叫做方法的接收者，方法的接收者与方法的参数统称做方法的宗量。比如下面例子中的Test类。

public class Test {
    public void print(String str) {
        System.out.println(str);
    }
}

    1
    2
    3
    4
    5

在上面的类中，print()方法属于Test对象，所以它的接收者也就是Test对象了。print()方法有一个参数是str，它的类型是String。

根据分派可以基于多少种宗量，可以将面向对象的语言分为单分派语言（Uni-Dispatch）和多分派语言（Multi-Dispatch）。单分派语言根据一个宗量的类型进行对方法的选择，多分派语言根据多于一个的宗量类型对方法进行选择。

C++和Java均是单分派语言，多分派语言的例子包括CLOS和Cecil。按照这样的区分，Java就是动态的单分派语言，因为这种语言的动态分派仅仅会考虑到方法的接收者的类型，同时又是静态的多分配语言，因为这种语言对重载方法的分派会考虑到方法的接收者的类型以及方法的所有参数的类型。

在一个支持动态单分派的语言里面，有两个条件决定了一个请求会调用哪一个操作：一是请求的名字，而不是接收者的真实类型。单分派限制了方法的选择过程，使得只有一个宗量可以被考虑到，这个宗量通常就是方法的接收者。在JAVA语言里面，如果一个操作是作用于某个类型不明的对象上面，那么对这个对象的真实类型测试仅会发生一次，这就是动态地单分派的特征。
双重分派

一个方法根据两个宗量的类型来决定执行不同的代码，这就是“双重分派”。Java语言不支持动态的多分派，也就意味着Java不支持动态地双分派。但是通过使用设计模式，也可以在Java语言里实现动态地双重分派。

在Java中可以通过两次方法调用来达到两次分派的目的。类图如下所示：

west east uml 类图

在图中有两个对象，左边的叫做West，右边的叫做East。现在West对象首先调用East对象的goEast()方法，并将它自己传入。在East对象被调用的时候，立即根据传入的参数知道了调用者是谁，于是反过来调用“调用者”对象的goWest()方法。通过两次调用将程序控制权轮番交给两个对象，其时序图如下所示：

east west 时序图

这样就出现了两次方法调用，程序控制权被两个对象像传球一样，首先由West对象传给了East对象，然后又被反传给了West对象。

但是仅仅反传一下球，并不能解决双重分派的问题。关键是怎样利用这两次调用，以及Java语言的动态单分派功能，使得在这种传球的过程中，能够触发两次单分派。

动态单分派在JAVA语言中是在子类重写父类的方法时发生的。换言之，West和East都必须分别置身于自己的类型等级结构中，如下图所示：

west east UML类图

访问者模式涉及到的角色如下：

    抽象访问者（Visitor）角色：声明了一个或多个方法操作，形成所有的具体访问者角色必须实现的接口。
    具体访问者（ConcreteVisitor）角色：实现抽象访问者所声明的接口，也就是抽象访问者所声明的各个访问操作。
    抽象节点（Node）角色：声明一个接受操作，接受一个访问者对象作为一个参数。
    具体节点（ConcreteNode）角色：实现了抽象节点所规定的的接受操作。
    结构对象（ObjectStructure）角色：有如下责任，可以遍历结构中的所有元素；如果需要，提供一个高层次的接口，让访问者对象可以访问每一个元素；如果需要，可以设计成一个复合对象或者一个聚集，如List或Set。

访问者模式的优点

能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。

    好的复用性
    可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。
    分离无关行为
    可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。

访问者模式的缺点

    对象结构变化很困难
    不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。
    破坏封装
    访问者模式通常需要对象结构开发内部数据给访问者和ObjectStructure，这破坏了对象的封装性。
